"""Add dietary_tags to potluck_claims for multi-claim support

Revision ID: 34abe2b1de29
Revises: 8571422129a5
Create Date: 2025-12-02 17:58:23.687393

This migration:
1. Adds dietary_tags column to potluck_claims table
2. Migrates existing legacy claims (claimed_by_person_id on potluck_items) to PotluckClaim records
"""
from alembic import op
import sqlalchemy as sa
from datetime import datetime
import json


# revision identifiers, used by Alembic.
revision = '34abe2b1de29'
down_revision = '8571422129a5'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('potluck_claims', schema=None) as batch_op:
        batch_op.add_column(sa.Column('dietary_tags', sa.JSON(), nullable=True))

    # ### end Alembic commands ###

    # Migrate legacy claims from potluck_items to potluck_claims
    conn = op.get_bind()

    # Find all suggested items with legacy claims (claimed_by_person_id set)
    result = conn.execute(
        sa.text("""
            SELECT pi.id, pi.claimed_by_person_id, pi.claimer_notes, pi.claimer_dietary_tags, pi.claimed_at
            FROM potluck_items pi
            WHERE pi.is_suggested = 1 AND pi.claimed_by_person_id IS NOT NULL
        """)
    )
    legacy_claims = result.fetchall()

    migrated_count = 0
    for row in legacy_claims:
        item_id, person_id, notes, dietary_tags_json, claimed_at = row

        # Check if a PotluckClaim already exists for this item/person combo
        existing = conn.execute(
            sa.text("""
                SELECT id FROM potluck_claims
                WHERE potluck_item_id = :item_id AND person_id = :person_id
            """),
            {"item_id": item_id, "person_id": person_id}
        ).fetchone()

        if existing:
            print(f"  Skipping item {item_id} - claim already exists for person {person_id}")
            continue

        # Get household_id for the person
        household_result = conn.execute(
            sa.text("""
                SELECT household_id FROM household_memberships
                WHERE person_id = :person_id AND is_active = 1
                LIMIT 1
            """),
            {"person_id": person_id}
        ).fetchone()
        household_id = household_result[0] if household_result else None

        # Parse dietary tags if they exist
        dietary_tags = None
        if dietary_tags_json:
            try:
                dietary_tags = json.loads(dietary_tags_json) if isinstance(dietary_tags_json, str) else dietary_tags_json
            except (json.JSONDecodeError, TypeError):
                dietary_tags = None

        # Create PotluckClaim record
        conn.execute(
            sa.text("""
                INSERT INTO potluck_claims (potluck_item_id, person_id, household_id, claimed_at, notes, dietary_tags)
                VALUES (:item_id, :person_id, :household_id, :claimed_at, :notes, :dietary_tags)
            """),
            {
                "item_id": item_id,
                "person_id": person_id,
                "household_id": household_id,
                "claimed_at": claimed_at or datetime.utcnow().isoformat(),
                "notes": notes,
                "dietary_tags": json.dumps(dietary_tags) if dietary_tags else None
            }
        )
        migrated_count += 1
        print(f"  Migrated claim for item {item_id} by person {person_id}")

    if migrated_count > 0:
        print(f"  Migrated {migrated_count} legacy claims to PotluckClaim records")
    else:
        print("  No legacy claims to migrate")


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('potluck_claims', schema=None) as batch_op:
        batch_op.drop_column('dietary_tags')

    # ### end Alembic commands ###

    # Note: We don't delete the migrated PotluckClaim records on downgrade
    # because the legacy fields still exist on potluck_items and will continue to work
